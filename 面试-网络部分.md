## HTTP请求的过程

``` 
1. DNS解析
   DNS解析的过程就是根据域名查找IP地址
2. TCP连接
   * 浏览器根据IP地址向服务器地址发起TCP连接, 与服务器建立TCP三次握手
   2.1 浏览器向服务器发送了一个建立连接的请求
   2.2 服务器接收到请求之后 发送同意连接的信号
   2.3 浏览器接受到同意连接信号后, (再次向服务器发送了确认信号)
   浏览器与服务器两者建立了连接
3. 浏览器发送http请求
   请求由三部分组成 请求行, 请求报头 和 请求正文
4. 服务器处理请求并返回http报文
   http响应报文也是有三部分组成 状态码, 响应报头 和 响应报文
5. 浏览器解析渲染页面
   浏览器拿到html文件后, 开始解析文件中的html代码, 遇到静态资源时, 就向服务器端去请求下载 这时 就会使用keep-alive特性, 建立一次http连接 可以请求多个资源 ,下载资源的顺序就是按照代码里面的顺序, 但是由于每一个资源大小不一样 而浏览器又是多线程请求资源 所以显示的顺序并一定是按照代码里面的顺序
6. 浏览器渲染页面
   浏览器利用自己内部的工作机制, 把请求的静态资源和html代码进行渲染, 渲染之后呈现给用户
```

## TCP协议

名为传输层协议, 是一种可靠的传输层协议

* 四次挥手 (关闭TCP连接)
  ```
  1. 第一次挥手 - 客户端向服务端发送断开连接的请求
  2. 第二次挥手 - 服务端接收到断开连接的请求, 但是需要确认数据是否已经传输完毕, 所以先发送同意断开连接的请求
  3. 第三次挥手 - 服务端数据传输完毕后, 发送断开连接请求
  4. 第四次挥手 - 客户端接收到服务端断开连接请求后, 告知服务端 已接收到服务端向其发送的断开连接的请求
  ```

## post和get请求

1. GET中的重点是从服务器上获取资源, POST重点向服务器发送数据
2. GET请求的参数对用户来说是可见的(通过url请求),  POST请求的参数都是封存到请求体重, 这个过程对用户是不可见的。GET是不安全的， POST的安全性较高。
3. GET请求的传输数据量是有限度的，因为url的长度是有限的，但是效率比较高。POST可以传输大量的数据量，所以上传文件时只能使用POST的方式
4. get方式只能支持ASCII字符, 向服务端传的中文字符可能会是乱码。POST支持字符集,可以正确传递中文字符。

## web性能优化

1. 图片格式转换为webp
2. 使用懒加载
3. 减少http请求的数量, 

## 协商缓存和强缓存

1. 强缓存 
   
   获取资源 - 从缓存取
   状态码 - 200(from cache)
   不需要请求到服务器(直接在缓存中取)
   ```
   当浏览器去请求某个资源时, 服务端就在响应头的cache-control里对该资源做了缓存配置。缓存时间，缓存类型都由服务端控制。

   常见的设置
   max-age 缓存时间
   public - 表示可以被浏览器和代理服务器缓存
   no-cache - 不是用强缓存
   immutable - 浏览器不会发起请求 直接从磁盘或则内存中读取缓存并返回200状态(from memory cache)

   ```
2. 协商缓存
   获取资源 - 从缓存中取
   状态码 - 304(not modified)
   通过服务器来告知缓存是否可以使用

   ```   
   通过max-age判断缓存是否失效了 失效,请求服务端, 然后带上etag 和 last modified,服务端会把带过来的表示进行对比, 然后判断资源是否更改额, 如果更改就直接返回新的资源, 如果资源没有改变, 就不改变etag 和 last-modified。 这个时候对于浏览器来说每次都是要进行协商缓存的。

   如果资源没有改 返回304 浏览器读取本地缓存。
   如果资源发生改变，返回200 返回最新的资源。

   发送请求的时候 请求带的etag和last-modified会换一个key值

   if-etag-matched
   if-modified-since

   ```

   ## HTTP的长链接和短链接

   

   